using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.SignalR;
using VulnerabilityMonitoring.Authentication;
using VulnerabilityMonitoring.Models.Dtos;
using VulnerabilityMonitoring.Models.ViewModels;
using VulnerabilityMonitoring.Services.API;
using VulnerabilityMonitoring.Services.Application;
using VulnerabilityMonitoring.Services.Email;
using VulnerabilityMonitoring.Services.Notification;
using VulnerabilityMonitoring.Services.Scan;

namespace VulnerabilityMonitoring.Controllers;

[Route("api/[controller]")]
[ApiController]
[ServiceFilter(typeof(BasicAuth))]
public class ServiceHookController : ControllerBase
{
    private readonly ILogger<ServiceHookController> _logger;
    private readonly IAzureDevOpsService _azureDevOps;
    private readonly ISendEmail _sendEmail;
    private readonly IVulnerabilityScanService _vulnerabilityScan;
    private readonly IProjectManagementService _managementService;
    private readonly IHubContext<NotificationHub> _hubContext;





    public ServiceHookController(ILogger<ServiceHookController> logger, IAzureDevOpsService azureDevOps, IVulnerabilityScanService vulnerabilityScan, IProjectManagementService managementService, ISendEmail sendEmail, IHubContext<NotificationHub> hubContext)
    {
        _logger = logger;
        _azureDevOps = azureDevOps;
        _vulnerabilityScan = vulnerabilityScan;
        _managementService = managementService;
        _sendEmail = sendEmail;
        _hubContext = hubContext;

    }


    [HttpPost]
    [Route("Build")]
    public async Task<IActionResult> BuildPipeline([FromBody] BuildWebhookDto data)
    {

        try
        {

            if (!ModelState.IsValid)
            {
                _logger.LogError("Invalid model state");
                return BadRequest(ModelState);
            }

            // if Status is not "completed" or Result is not "succeeded" then return
            if (data.Resource?.Status != "completed" || data.Resource?.Result != "succeeded")
            {
                _logger.LogInformation("Build not completed or not succeeded");
                return BadRequest();
            }
            _logger.LogInformation("Build completed and succeeded");



            var activeProject = await _managementService.GetProjectAsync(data.Resource.Repository.Id);
            string activeProjectBranchName = activeProject.Branch;
            string SourceBranch = data.Resource.SourceBranch;
            // om activeProject är inte null och activeProjectBranchName är lika med newBranchName       
            if (activeProject != null && activeProjectBranchName == SourceBranch)
            {
                // Delete Local Project Directory
                await _azureDevOps.DeleteLocalProjectDirectoryAsync(activeProject.ProjectsPath);

                // Save To local Directory
                var result = await _azureDevOps.SaveRepositoryFilesLocallyAsync(data.Resource.Repository.Id);
                if (result == null)
                {
                    Response.Headers.Append("Custom-Message", "Cannot save to local directory");
                    return NotFound();
                }


                // Save To Database 
                await _managementService.UpdateProjectWebHookAsync(result);
                _logger.LogInformation("Project updated successfully");



                VulnerableProjectViewModels viewModel = new VulnerableProjectViewModels();
                viewModel.ProjectsPath = activeProject.ProjectsPath + "\\" + activeProject.ProjectSloName;
                viewModel.ProjectSloName = activeProject.ProjectSloName;
                viewModel.RepositoryId = activeProject.RepositoryId;
                // Kör sårbarhetsskanning för det aktuella projektet
                var scanresult = await _vulnerabilityScan.RunVulnerabilityScanResultAsync(viewModel);
                if (scanresult.VulnerableProjectPackage.Count > 0)
                {

                    // Skicka e-postmeddelande om det finns sårbarheter
                    await _sendEmail.SendVulnerabilityWarningEmailAsync(scanresult);
                }

                // Skicka meddelande till klienten via SignalR 
                string message = "Från ScheduleJob";
                await _hubContext.Clients.All.SendAsync("ReceiveMessage", message);



                Response.Headers.Append("Custom-Message", "Project updated successfully");
                return Ok();
            }
            if (activeProject != null && activeProjectBranchName != SourceBranch)
            {
                _logger.LogInformation("Branch name is not equal to active project branch name");
                Response.Headers.Append("Custom-Message", "Branch name is not equal to active project branch name");
                return Accepted();
            }
            _logger.LogInformation("Project not found in database");
            Response.Headers.Append("Custom-Message", "Project not found in database");
            return NotFound();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing Azure DevOps webhook");
            return StatusCode(500);
        }
    }

}
